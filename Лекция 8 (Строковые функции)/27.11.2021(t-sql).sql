/*
Задача 1
Напишите запрос, который вернет первые 100 наиболее молодых сотрудников мужского пола.
- Используется таблица [HumanResources].[Employee]
- Результирующий набор данных содержит: Идент. сотр, Уникальный государственный идентификационный номер, дату рождения
  Описание таблицы можно видеть по ссылке
https://dataedo.com/samples/html/AdventureWorks/doc/AdventureWorks_2/tables/HumanResources_Employee_130.html
*/
select top 100
       t1.BusinessEntityID,
       t1.NationalIDNumber,
	   t1.BirthDate
  from [HumanResources].[Employee] as t1
 where t1.Gender = N'M'
 order by t1.BirthDate desc;


/*
Задача 2
Напишите запрос, который вернет список уникальных наименований должностей.
Исключите сотрудников, которые состоят в браке.
- Используется таблица [HumanResources].[Employee]
- Результирующий набор данных содержит: Наименование должности
- Задействуйте оператор DISTINCT
- Отсортируйте результат по наименованию должности (по возрастанию)
  Описание таблицы можно видеть по ссылке
  https://dataedo.com/samples/html/AdventureWorks/doc/AdventureWorks_2/tables/HumanResources_Employee_130.html
*/
select distinct 
       t1.JobTitle
  from [HumanResources].[Employee] as t1
 where t1.MaritalStatus != N'M'
 order by t1.JobTitle;

/*
Задача 3
Напишите запрос, который в разрезе должности и пола вернет кол-во часов отпуска и кол-во часов отпуска по болезни
и разницу между ними. Исключите сотрудников с окладом, без участия в коллективном договоре (SalariedFlag != 0). 
Исключите группы строк, у которых кол-во часов отпуска больше или равна кол-ву часов отпуска по болезни (общая сумма в разрезе должности и пола).
- Используется таблица [HumanResources].[Employee]
- Результирующий набор данных содержит: Наименование должности, пол, кол-во часов отпуска, кол-во часов отпуска по болезни, разницу.
- Задействуйте агрегатную функцию SUM
- Отсортируйте результат по разнице (по убыванию)
  Описание таблицы можно видеть по ссылке
  https://dataedo.com/samples/html/AdventureWorks/doc/AdventureWorks_2/tables/HumanResources_Employee_130.html
*/
select t1.JobTitle, 
       t1.Gender,
	   sum(VacationHours) as [VacationHoursSum],
	   sum([SickLeaveHours]) as [SickLeaveHoursSum],
	   sum(VacationHours) -  sum([SickLeaveHours]) as [total]
  from [HumanResources].[Employee] as t1
 where t1.SalariedFlag != 0
 group by t1.JobTitle, 
          t1.Gender
 having not sum(VacationHours) >=  sum([SickLeaveHours])
 order by [total] desc;

/*
Задача 4
Напишите запрос, который в разрезе идент. территории ([TerritoryID]) вернет кол-во уникальных заказов. Учитывайте только заказы за октябрь 2011 (year(t1.OrderDate) = 2011  and month(t1.OrderDate) = 10) . 
Исключите заказы размещенные клиентом через сеть (OnlineOrderFlag != 1). Уникальный идентификационный номер заказа на продажу(SalesOrderNumber) должен начинаться на %SO44.
- Используется таблица [Sales].[SalesOrderHeader].
  https://dataedo.com/samples/html/AdventureWorks/doc/AdventureWorks_2/tables/Sales_SalesOrderHeader_185.html
- Результирующий набора данных содержит: идент. территории, кол-во уникальных заказов 
- Отсортируйте результат по кол-ву заказов (по убыванию)
*/

select t1.TerritoryID,
       count(distinct t1.SalesOrderNumber) as [order_qty]
  from [Sales].[SalesOrderHeader] as t1
 where year(t1.OrderDate) = 2011  
   and month(t1.OrderDate) = 10
   and OnlineOrderFlag != 1
   and SalesOrderNumber like 'SO44%'
 group by t1.TerritoryID
 order by [order_qty] desc;

--=================================================================================================================================================================================================================
-- Строковые функции 
-- ASCII - Возвращает код ASCII первого символа указанного символьного выражения.

select t1.NationalIDNumber,
       ASCII(t1.NationalIDNumber) as [ASCII]
  from [HumanResources].[Employee] as t1;

-- select ASCII(' ') -- Неразрывный пробел
-- select ASCII(' ') -- Пробел
-- select ASCII('Å')
SELECT ASCII('æ') AS [Extended_ASCII];

--=================================================================================================================================================================================================================

select UNICODE(N'Å')
SELECT UNICODE('æ') AS [Extended_ASCII], NCHAR(230) AS [CHARACTER];
--=================================================================================================================================================================================================================
-- CHAR - Возвращает символ по кодировке ASCII
select CHAR(248);

-- select CHAR(ASCII(' '))
--=================================================================================================================================================================================================================
select NCHAR(248) -- ø

--=================================================================================================================================================================================================================
-- CHARINDEX -- Эта функция выполняет поиск одного символьного выражения внутри второго символьного выражения, возвращая начальную позицию первого выражения, если найдено.
select t1.JobTitle,
       charindex('D', t1.JobTitle) as [INDEX]
  from [HumanResources].[Employee] as t1;

select charindex('Develop','Research and Development Manager', 13);
--=================================================================================================================================================================================================================
-- CONCAT/ CONCAT_WS - конкатенация строк
select t1.FirstName,
       t1.MiddleName,
	   concat(t1.FirstName, ' ', t1.MiddleName /*, */) as [full_name],
	   concat_ws(' ', t1.FirstName, t1.MiddleName)     as [full_name2],
	   t1.FirstName + ' ' +  isnull(t1.MiddleName, '') as [full_name3]
  from [Person].[Person] as t1;
--=================================================================================================================================================================================================================
-- Format - Возвращает значение в указанных формате и культуре (не обязательно). Для выполнения форматирования значения даты, времени и чисел с учетом локали в виде строк используется функция FORMAT. Для общих преобразований типов данных продолжайте использовать CAST и CONVERT.
select 
       t1.HireDate,
       format(t1.HireDate, 'dd/MM/yyyy', 'en-US')
  from [HumanResources].[Employee] as t1;

select format(convert(bigint, concat(t1.CardNumber, '00')), '####-####-####-####'),
       format(convert(bigint, t1.CardNumber), '####-####-####-##')
  from [Sales].[CreditCard] as t1;
--=================================================================================================================================================================================================================
-- LEFT - Возвращает указанное число символов символьного выражения слева.
select t1.CardNumber,
       left(t1.CardNumber, 4) as [left]
  from [Sales].[CreditCard] as t1;

-- RIGHT - Возвращает указанное число символов символьного выражения справа.
select t1.CardNumber,
       RIGHT(t1.CardNumber, 4) as [left]
  from [Sales].[CreditCard] as t1;
--=================================================================================================================================================================================================================
-- LEN - Возвращает количество символов указанного строкового выражения, исключая конечные пробелы.
select t1.CardNumber,
       len(concat(' ', ' ', ' ', t1.CardNumber, ' ', ' ', ' ')) as [symbolQty]
  from [Sales].[CreditCard] as t1;
--=================================================================================================================================================================================================================
select t1.FirstName,
       lower(t1.firstName) as [lower],
	   upper(t1.FirstName) as [upper]
  from [Person].[Person] as t1;
--=================================================================================================================================================================================================================
-- LTRIM  - Возвращает символьное выражение после удаления начальных пробелов.
select t1.PersonType,
       ltrim(  replace(concat(' ', ' ', t1.PersonType), char(ascii('  ')), ' '   ))
  from [Person].[Person] as t1;

-- RTRIM 
select t1.PersonType,
       rtrim(concat(t1.PersonType, ' ', ' '))
  from [Person].[Person] as t1;  

select ltrim('  T - SQL  '),
       rtrim('  T - SQL  '),
       trim('  T - SQL  '),
	   replace('  T - SQL  ', ' ', '')
--=================================================================================================================================================================================================================
-- Возвращает строку пробелов.
select space(10);
          
--=================================================================================================================================================================================================================
-- REPLICATE  - Повторяет значение строки указанное число раз.
select t1.FirstName,
       replicate(concat(t1.FirstName, ' '), 5)
  from [Person].[Person] as t1;
--=================================================================================================================================================================================================================
-- REVERSE  Возвращает строковое значение, где символы переставлены в обратном порядке справа налево.
select t1.FirstName,
       reverse(t1.FirstName)
  from [Person].[Person] as t1;
--=================================================================================================================================================================================================================
-- PATINDEX Для любого допустимого символьного или текстового типа данных возвращает начальную позицию первого вхождения шаблона в указанном выражении или нули, если шаблон не найден
select t1.LastName,
       patindex('%bie', t1.LastName),
	   patindex('%ifi%', t1.LastName)
  from [Person].[Person] as t1
 where patindex('%ifi%', t1.LastName) != 0
    or patindex('%bie', t1.LastName) != 0;
--=================================================================================================================================================================================================================
-- STUFF Функция STUFF вставляет одну строку в другую. Она удаляет указанное количество символов первой строки в начальной позиции и вставляет на их место вторую строку.
select t1.CardNumber, 
       stuff(t1.CardNumber, 5, 6, '******')
  from [Sales].[CreditCard] as t1;
--=================================================================================================================================================================================================================
-- STR - Возвращает символьные данные, преобразованные из числовых данных. Символьные данные выровнены по правому краю с заданной длиной и десятичной точностью.
select t1.SubTotal,
       concat_ws(' ', str(t1.SubTotal, 15,2), 'USD')
  from [Sales].[SalesOrderHeader] as t1
--=================================================================================================================================================================================================================
-- SUBSTRING 
select t1.CardNumber,
       substring(t1.CardNumber, 4, 4)
  from [Sales].[CreditCard] as t1

--=================================================================================================================================================================================================================
-- STRING_SPLIT - функция с табличным значением, которая разбивает строку на строки подстрок в зависимости от указанного знака разделения.
select top 1 
       with ties
       *
  from string_split('Lorem ipsum dolor sit amet.', ' ')
  order by len(value) desc
--=================================================================================================================================================================================================================
/*
create table dbo.numbers (
       [ID] nvarchar(50) not null
)
*/
/*
insert into [dbo].[numbers] ([ID])
values('1E+8'),  
      ('9876'),
	  ('456AB'),
	  ('786HC44'),
	  ('4567833'),
	  ('335889'),
	  ('44'),
	  ('44B')*/
-- LEN
-- REPLICATE '[0-9]'
-- LIKE
--=================================================================================================================================================================================================================
select t1.ID,
       len(t1.ID),
	   replicate('[0-9]', len(t1.ID))
  from [dbo].[numbers] as t1
 where t1.ID like replicate('[0-9]', len(t1.ID))
 order by len(t1.ID) desc;

select t1.ID
  from [dbo].[numbers] as t1
 where try_convert(int, t1.ID) is not null
 order by len(t1.ID) desc;

select t1.ID
  from [dbo].[numbers] as t1
 where isnumeric(t1.ID) = 1
 order by len(t1.ID) desc;
--=================================================================================================================================================================================================================
select t1.EmailAddress,
       substring(t1.EmailAddress, 1, charindex('@', t1.EmailAddress) - 1 ),
       charindex('@', t1.EmailAddress) - 1
  from [Person].[EmailAddress] as t1
 where -- Отобрать емейлы где указана @
       t1.EmailAddress like '%@%'
   and substring(t1.EmailAddress, 1, charindex('@', t1.EmailAddress) - 1) like replicate('[A-z]', len(substring(t1.EmailAddress, 1, charindex('@', t1.EmailAddress) - 1)));
  
--=================================================================================================================================================================================================================
select
       distinct 
       top 1
       with ties
	   t1.EmailAddress,
	   len(substring(t1.EmailAddress, 1, charindex('@', t1.EmailAddress) - 1)) 
  from [Person].[EmailAddress] as t1
 where -- Отобрать емейлы где указана @
       t1.EmailAddress like '%@%'
   and substring(t1.EmailAddress, 1, charindex('@', t1.EmailAddress) - 1) like replicate('[A-z]', len(substring(t1.EmailAddress, 1, charindex('@', t1.EmailAddress) - 1)))
 order by len(substring(t1.EmailAddress, 1, charindex('@', t1.EmailAddress) - 1)) desc;
--=================================================================================================================================================================================================================

select t1.BusinessEntityID,
       upper(concat_ws(N' ', t1.LastName, t1.FirstName, t1.MiddleName)) as [fio]
  from [Person].[Person] as t1
 where len(t1.LastName) between 7 and 9
 order by len(t1.LastName) desc;

